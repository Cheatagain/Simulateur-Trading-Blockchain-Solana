<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Simulation Trading Dexscreener</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      padding: 10px;
      display: flex;
      gap: 20px;
      background-color: #121212;
      color: white;
    }
    #dexscreener-embed {
      position: relative;
      width: 100%;
      padding-bottom: 60%;
      background-color: #1c1c1c;

    }
    #dexscreener-embed iframe {
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      border: 0;
    }
    #search-container {
      width: 40%;
      display: flex;
      flex-direction: column;
    }
    input, button {
      font-size: 14px;
      margin: 5px 0;
      padding: 8px;
      border-radius: 5px;
      border: none;
    }
    #config-form {
      background-color: #222;
      padding: 5px;
      margin-top: 5px;
      border-radius: 5px;
    }
    #results {
      border: 1px solid #555;
      max-height: 250px;
      overflow-y: auto;
      display: none;
      background-color: #222;
      border-radius: 5px;
    }
    .result-item {
      padding: 8px;
      cursor: pointer;
      border-bottom: 1px solid #444;
    }
    .result-item:hover {
      background-color: #333;
    }
    #token-info, #ohlc-data {
      margin-top: 10px;
      background-color: #222;
      padding: 15px;
      border-radius: 5px;
    }
    .notification {
      margin: 5px 0;
      padding: 8px;
      border-radius: 5px;
      background-color: #113311;
    }
	.ai-confirmation {
    border-left: 3px solid #4CAF50;
    padding-left: 10px;
    margin: 10px 0;
	}
	</style>
	<!-- Chargement des figures de trading -->
	<script src="figures.signal.achat.js"></script> <!-- Chargement des figures de trading -->
	<script src="IA/DoubleBottomConfirmer.js"></script> 
</head>
<body>
  <div id="dexscreener-embed">
    <span id="placeholder-message">Merci de choisir un token</span>
  </div>

  <div id="search-container">
    <h2>Recherche de Token</h2>
    <input type="text" id="search" placeholder="üîç Nom, symbole ou adresse..." autocomplete="off" />
    
    <div id="results"></div>
    <div id="token-info"></div>
    <div id="config-form" style="display: none;">
  <h3>Param√®tres</h3>
  <div style="display: flex; justify-content: space-between;">
    <div>
      <h4>Param√®tres du Simulateur</h4>
	       <label for="timeframe-select">Timeframe:</label>
      <select id="timeframe-select">
          <option value="1" selected>1m</option>
          <option value="5" >5m</option>
          <option value="15">15m</option>
          <option value="60">1h</option>
      </select><br/><br/>
	  <label><input type="checkbox" id="enable-PositiveVariation" checked /> D√©tection Positive Variation</label><br/>
	  <label><input type="checkbox" id="enable-fvg" checked /> D√©tection FVG</label><br/>
	  <label><input type="checkbox" id="enable-double-bottom" checked /> D√©tection Double Bottom</label><br/>
	  <label><input type="checkbox" id="enable-triple-bottom" checked /> D√©tection Triple Bottom Prix Temps Reel</label><br/>
	  <div id="triple-bottom-status" style="margin-top:5px; font-size:14px; color:gray;"></div>
	  <label><input type="checkbox" id="enable-BullishRectangle" checked /> D√©tection BullishRectangle</label><br/>
	  <label><input type="checkbox" id="enable-InvertedHeadAndShoulders" checked /> D√©tection Inverted Head & Shoulders</label><br/>
	  <label><input type="checkbox" id="enable-DoubleBottomBullishRectangleCombo" checked /> D√©tection Combo Double Bottom & BullishRectangle</label><br/>
	  <label><input type="checkbox" id="enable-InvertedHSDoubleBottomCombo" checked /> D√©tection Combo Inverted HS & DB</label><br/>
      <label><input type="checkbox" id="enable-hammer" checked /> D√©tection Hammer</label><br/>
      <label><input type="checkbox" id="enable-engulfing" checked /> D√©tection Bullish Engulfing</label><br/>
      <label>Take Profit (%) : <input type="number" id="tp-input" value="10" /></label><br/>
      <label>Trailing Stop (%) : <input type="number" id="trailing-input" value="10" /></label><br/>
	  <label>Stop Loss (%) : <input type="number" id="sl-input" value="25" /></label><br/>
      <label>Max Stop Loss : <input type="number" id="max-sl-input" value="3" /></label><br/>
	  
    </div>
    
    <div>
      <h4>Param√®tres TRADE DBOT API </h4>
	  <label>Montant du Trade (SOL) : <input type="number" id="trade-amount" value="0.00" step="0.01" min="0" /></label><br/>
    </div>
  </div>
  
  <div style="margin-top: 20px;">
    <button onclick="updateConfig()">Mettre √† jour</button>
    <button id="simulate-detection" style="padding: 10px; margin: 10px; background-color: #444; color: white; border: none; border-radius: 5px;">üöÄ Simuler un Double Bottom</button>
	<button id="simulate-triple-bottom" style="padding: 10px; margin: 10px; background-color: #444; color: white; border: none; border-radius: 5px;">üî∫ Simuler un Triple Bottom</button>
    <button id="simulate-trailing" style="padding: 10px; margin: 10px; background-color: #444; color: white; border: none; border-radius: 5px;">üéØ Simuler un Trailing Stop</button>
	<button id="simulate-stoploss" style="padding: 10px; margin: 10px; background-color: #444; color: white; border: none; border-radius: 5px;">üéØ Simuler un Stop Loss</button>
  </div>
 
</div>
<div id="log"></div>
<div id="triple-bottom-status"></div>
<div id="ohlc-data"></div>

  <script>
  
 
	// 1. D√©finir les variables globales)
    const searchInput = document.getElementById("search");
    const resultsDiv = document.getElementById("results");
    const tokenInfoDiv = document.getElementById("token-info");
    const chartContainer = document.getElementById("dexscreener-embed");
    const ohlcDataDiv = document.getElementById("ohlc-data");
    const configFormDiv = document.getElementById("config-form");
	const minDetectionDelay = 300000; // 60 secondes entre les d√©tections
	const minTradeDelay = 60000; // 60 secondes en millisecondes
	const logDiv = document.getElementById("log");
	// R√©cup√®re le selection du timeframe et initialise la valeur globale
	window.selectedTimeframe = parseInt(document.querySelector('#timeframe-select').value, 10);

	// Mettre √† jour si l'utilisateur change le select
	document.querySelector('#timeframe-select').addEventListener('change', (e) => {
    window.selectedTimeframe = parseInt(e.target.value, 10);
    console.log("Timeframe mis √† jour :", window.selectedTimeframe, "minutes");
	});
	
	

	
	let selectedPair = null;
    let priceUpdateInterval = null;
    let priceHistory = [];
    let activeTrade = null;
    let stopLossCounter = 0;
    let ohlcSeries = [];
    let lastTokenUpdate = null;
	let lastDetectionTime = 0;
	let lastTradeTime = 0;
	

	window.priceHistory = window.priceHistory || [];


    let config = {
      sl: 25,
      tp: 10,
      trailing: 10,
      maxSL: 3,
	  detectPositiveVariation: false,
	  detectBullishFVGUnderFib: false,
	  detectDoubleBottom: false,
	  detectTripleBottom: false,
	  detectBullishRectangle: false,
	  detectInvertedHeadAndShoulders: false,
	  detectDoubleBottomBullishRectangleCombo: false,
	  detectInvertedHSDoubleBottomCombo: false,
      detectHammer: false,
      detectEngulfing: false,
	 };

    // Initialisation
    fetch('/configParams')
      .then(response => response.json())
      .then(data => {
        // Met √† jour la config locale
        Object.assign(config, data);
        
        // Met √† jour les champs du formulaire
        document.getElementById("sl-input").value = data.sl;
        document.getElementById("tp-input").value = data.tp;
        document.getElementById("trailing-input").value = data.trailing;
        document.getElementById("max-sl-input").value = data.maxSL;
		document.getElementById("enable-PositiveVariation").checked = data.detectPositiveVariation !== false;
		document.getElementById("enable-fvg").checked = data.detectBullishFVGUnderFib !== false;
		document.getElementById("enable-double-bottom").checked = data.detectDoubleBottom !== false;
		document.getElementById("enable-triple-bottom").checked = data.detectTripleBottom !== false;
		document.getElementById("enable-BullishRectangle").checked = data.detectBullishRectangle !== false;
		document.getElementById("enable-InvertedHeadAndShoulders").checked = data.detectInvertedHeadAndShoulders !== false;
		document.getElementById("enable-DoubleBottomBullishRectangleCombo").checked = data.detectDoubleBottomBullishRectangleCombo !== false;
		document.getElementById("enable-InvertedHSDoubleBottomCombo").checked = data.detectInvertedHSDoubleBottomCombo !== false;
        document.getElementById("enable-hammer").checked = data.detectHammer !== false;
        document.getElementById("enable-engulfing").checked = data.detectEngulfing !== false;

		
        // Si un token est configur√©, on le charge
        if (data.searchToken) {
          searchInput.value = data.searchToken;
          if (data.searchToken.length >= 2) {
            searchInput.dispatchEvent(new Event('input'));
          }
        }
      })
      .catch(console.error);

    // V√©rifie p√©riodiquement les mises √† jour
    setInterval(async () => {
      try {
        const res = await fetch('/configParams');
        const data = await res.json();
        
        // Met √† jour le token si n√©cessaire
        if (data.lastTokenUpdate && data.lastTokenUpdate !== lastTokenUpdate) {
          lastTokenUpdate = data.lastTokenUpdate;
          if (data.searchToken && data.searchToken !== searchInput.value) {
            searchInput.value = data.searchToken;
            const inputEvent = new Event('input', { bubbles: true });
            searchInput.dispatchEvent(inputEvent);
            
            // Attendre et s√©lectionner le premier r√©sultat
            await new Promise(resolve => setTimeout(resolve, 1500));
            const firstResult = document.querySelector('.result-item');
            if (firstResult) {
              firstResult.click();
              addNotification("Token charg√© automatiquement depuis Telegram");
            }
          }
        }
        
        // Met √† jour les autres param√®tres
        if (data.sl != config.sl) document.getElementById("sl-input").value = data.sl;
        if (data.tp != config.tp) document.getElementById("tp-input").value = data.tp;
        if (data.trailing != config.trailing) document.getElementById("trailing-input").value = data.trailing;
        if (data.maxSL != config.maxSL) document.getElementById("max-sl-input").value = data.maxSL;
		if (data.detectPositiveVariation != config.detectPositiveVariation) document.getElementById("enable-PositiveVariation").checked = data.detectPositiveVariation;
		if (data.detectBullishFVGUnderFib != config.detectBullishFVGUnderFib) document.getElementById("enable-fvg").checked = data.detectBullishFVGUnderFib;
		if (data.detectDoubleBottom != config.detectDoubleBottom) document.getElementById("enable-double-bottom").checked = data.detectDoubleBottom;
        if (data.detectTripleBottom != config.detectTripleBottom) document.getElementById("enable-triple-bottom").checked = data.detectTripleBottom;
		if (data.detectBullishRectangle != config.detectBullishRectangle) document.getElementById("enable-BullishRectangle").checked = data.detectBullishRectangle;
		if (data.detectInvertedHeadAndShoulders != config.detectInvertedHeadAndShoulders) document.getElementById("enable-InvertedHeadAndShoulders").checked = data.detectInvertedHeadAndShoulders;
		if (data.detectDoubleBottomBullishRectangleCombo != config.detectDoubleBottomBullishRectangleCombo) document.getElementById("enable-DoubleBottomBullishRectangleCombo").checked = data.detectDoubleBottomBullishRectangleCombo;
		if (data.detectInvertedHSDoubleBottomCombo != config.detectInvertedHSDoubleBottomCombo) document.getElementById("enable-InvertedHSDoubleBottomCombo").checked = data.detectInvertedHSDoubleBottomCombo;
		if (data.detectHammer != config.detectHammer) document.getElementById("enable-hammer").checked = data.detectHammer;
        if (data.detectEngulfing != config.detectEngulfing) document.getElementById("enable-engulfing").checked = data.detectEngulfing;
	
        
        // Met √† jour la config locale
        Object.assign(config, data);
        
      } catch (err) {
        console.error('Erreur v√©rification token:', err);
      }
    }, 1000);
	

    function addNotification(message) {
      const notification = document.createElement('div');
      notification.className = 'notification';
      notification.textContent = message;
      tokenInfoDiv.prepend(notification);
      setTimeout(() => notification.remove(), 5000);
    }

	function displayAIConfirmation(analysis) {
    const confirmationDiv = document.createElement('div');
    confirmationDiv.className = 'ai-confirmation';
    confirmationDiv.innerHTML = `
        <div style="background:#113311;padding:10px;border-radius:5px;margin-top:10px;">
            <strong>üß† CONFIRMATION IA</strong>
            <p>Confiance: <strong>${Math.round(analysis.confidence * 100)}%</strong></p>
            <p>SL recommand√©: <strong>${analysis.recommendedSl.toFixed(6)}</strong></p>
            ${analysis.details.insights ? `<p>${analysis.details.insights.join('<br>')}</p>` : ''}
        </div>
    `;
    tokenInfoDiv.appendChild(confirmationDiv);
	}

    function updateConfig() {
      config.sl = parseFloat(document.getElementById("sl-input").value);
      config.tp = parseFloat(document.getElementById("tp-input").value);
      config.trailing = parseFloat(document.getElementById("trailing-input").value);
      config.maxSL = parseInt(document.getElementById("max-sl-input").value);
	  config.tradeAmount = parseFloat(document.getElementById("trade-amount").value);
	  config.detectPositiveVariation = document.getElementById("enable-PositiveVariation").checked;
	  config.detectBullishFVGUnderFib = document.getElementById("enable-fvg").checked;
	  config.detectDoubleBottom = document.getElementById("enable-double-bottom").checked;
	  config.detectTripleBottom = document.getElementById("enable-triple-bottom").checked;
	  config.detectBullishRectangle = document.getElementById("enable-BullishRectangle").checked;
	  config.detectInvertedHeadAndShoulders = document.getElementById("enable-InvertedHeadAndShoulders").checked;
	  config.detectDoubleBottomBullishRectangleCombo = document.getElementById("enable-DoubleBottomBullishRectangleCombo").checked;
	  config.detectInvertedHSDoubleBottomCombo = document.getElementById("enable-InvertedHSDoubleBottomCombo").checked;
      config.detectHammer = document.getElementById("enable-hammer").checked;
      config.detectEngulfing = document.getElementById("enable-engulfing").checked;
	  // ‚úÖ Mise √† jour du timeframe global
	  config.timeframeSelect = document.getElementById("timeframe-select").value;
	  window.selectedTimeframe = config.timeframeSelect;
      console.log("‚è±Ô∏è Timeframe mis √† jour :", window.selectedTimeframe);
	 
	 
      
      fetch('/updateConfig', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(config)
      }).then(() => addNotification("Param√®tres mis √† jour !"))
        .catch(err => console.error(err));
    }

    function updateOHLC(price) {
    const now = new Date();
    const timeframe = window.selectedTimeframe || 1; <!-- // fallback 1 min -->
    const currentSlot = Math.floor(now.getMinutes() / timeframe); <!-- // "slot" du timeframe -->

    if (!ohlcSeries.length || ohlcSeries[ohlcSeries.length - 1].timeSlot !== currentSlot) {
        <!-- // Nouvelle bougie -->
        ohlcSeries.push({
            open: price,
            high: price,
            low: price,
            close: price,
            timeSlot: currentSlot,
            timestamp: now.getTime()
        });
        if (ohlcSeries.length > 200) ohlcSeries.shift();
        detectCandlestickPatterns();
    } else {
       <!--  // Mettre √† jour la bougie existante -->
        const last = ohlcSeries[ohlcSeries.length - 1];
        last.high = Math.max(last.high, price);
        last.low = Math.min(last.low, price);
        last.close = price;
		}
	}


    function isHammer(candle) {
      const body = Math.abs(candle.close - candle.open);
      const range = candle.high - candle.low;
      const lowerWick = Math.min(candle.open, candle.close) - candle.low;
      return body < range * 0.3 && lowerWick > body * 2 && candle.close > candle.open;
    }

    function isBullishEngulfing(prev, curr) {
      return (
        prev.close < prev.open &&
        curr.close > curr.open &&
        curr.open < prev.close &&
        curr.close > prev.open
      );
    }

    function detectCandlestickPatterns() {
      if (ohlcSeries.length < 3) return;

      const prevCandle = ohlcSeries[ohlcSeries.length - 2];
      const currentCandle = ohlcSeries[ohlcSeries.length - 1];
      
      if (config.detectHammer && isHammer(currentCandle)) {
        const message = `üî® Hammer d√©tect√© sur ${selectedPair?.baseToken?.symbol || 'Token'} √† ${currentCandle.close}`;
        addNotification(message);
        sendTelegramMessage(message);
      }
      
      if (config.detectEngulfing && isBullishEngulfing(prevCandle, currentCandle)) {
        const message = `üìà Bullish Engulfing d√©tect√© sur ${selectedPair?.baseToken?.symbol || 'Token'} √† ${currentCandle.close}`;
        addNotification(message);
        sendTelegramMessage(message);
      }
    }

    searchInput.addEventListener("input", async () => {
      if (priceUpdateInterval) clearInterval(priceUpdateInterval);
      selectedPair = null;
      tokenInfoDiv.innerHTML = "";
      chartContainer.innerHTML = '<span id="placeholder-message">Merci de choisir un token</span>';
      ohlcDataDiv.innerHTML = "";
      configFormDiv.style.display = "none";
      priceHistory = [];
      ohlcSeries = [];
      activeTrade = null;
      stopLossCounter = 0;

      const query = searchInput.value.trim();
      if (query.length < 2) {
        resultsDiv.style.display = "none";
        return;
      }

      try {
        const res = await fetch(`https://api.dexscreener.com/latest/dex/search/?q=${encodeURIComponent(query)}`);
        const data = await res.json();

        resultsDiv.innerHTML = "";
        if (data.pairs && data.pairs.length > 0) {
          data.pairs.slice(0, 10).forEach((pair) => {
            const item = document.createElement("div");
            item.className = "result-item";
            item.innerHTML = `<strong>${pair.baseToken.symbol}</strong> - ${pair.baseToken.name}<br/><small>${pair.chainId.toUpperCase()} | ${pair.dexId.toUpperCase()}</small>`;
            item.onclick = () => displayTokenInfo(pair);
            resultsDiv.appendChild(item);
          });
          resultsDiv.style.display = "block";
        } else {
          resultsDiv.style.display = "none";
        }
      } catch (err) {
        console.error("Erreur de recherche :", err);
      }
    });

    function extractPairIdFromUrl(url) {
      const match = url.match(/dexscreener\.com\/([^\/]+)\/([^\/?#]+)/);
      if (match) return { chain: match[1], pairId: match[2] };
      return null;
    }

// √Ä placer AVANT la fonction displayTokenInfo
const decimalsCache = new Map(); // Stockage m√©moire des d√©cimales

async function getTokenDecimals(mint) {
  // Si d√©j√† en cache, retourne imm√©diatement
  if (decimalsCache.has(mint)) return decimalsCache.get(mint);

  // Sinon, requ√™te unique via Jupiter Token List
  const response = await fetch('https://token.jup.ag/strict');
  const tokens = await response.json();
  const token = tokens.find(t => t.address === mint);
  const decimals = token?.decimals || 9; // Fallback technique interne
  
  decimalsCache.set(mint, decimals); // Mise en cache
  return decimals;
}

    async function displayTokenInfo(pair) {
      resultsDiv.style.display = "none";
      searchInput.value = `${pair.baseToken.symbol} - ${pair.baseToken.name}`;
      selectedPair = pair;
      const price = parseFloat(pair.priceUsd || 0);
	  const timeframeSelect = document.getElementById("timeframe-select"); // <-- ajout
	  const timeframe = timeframeSelect.value;
      console.log("‚è± Timeframe s√©lectionn√©:", timeframe);
	 	  

      tokenInfoDiv.innerHTML = `
        <h2>Informations sur le Token</h2>
        <p><strong>Nom :</strong> ${pair.baseToken.name}</p>
        <p><strong>Symbole :</strong> ${pair.baseToken.symbol}</p>
        <p><strong>Adresse :</strong> ${pair.baseToken.address}</p>
        <p><strong>DEX :</strong> ${pair.dexId}</p>
        <p><strong>Chain :</strong> ${pair.chainId}</p>
        <p><strong>Prix USD :</strong> <span id="price">${price}</span></p>
        <p><a href="${pair.url}" target="_blank">üîó Voir sur Dexscreener</a></p>
        <p id="price-error" style="color:red;"></p>
      `;

      configFormDiv.style.display = "block";

      const ids = extractPairIdFromUrl(pair.url);
      if (ids) {
        chartContainer.innerHTML = `
          <iframe src="https://dexscreener.com/${ids.chain}/${ids.pairId}?embed=1&chartTheme=dark&theme=dark&interval=${timeframeSelect}" allowfullscreen></iframe>
        `;
      }

       if (priceUpdateInterval) clearInterval(priceUpdateInterval);

		// 1. Chargement UNIQUE des d√©cimales au d√©but
		if (!decimalsCache.has(pair.baseToken.address)) {
		await getTokenDecimals(pair.baseToken.address);
		}
		
		// R√©cup√©ration des d√©cimales avec log suppl√©mentaire
  const baseDecimals = decimalsCache.get(pair.baseToken.address) || 9;
  console.log(`Configuration pour ${pair.baseToken.symbol}: 
    Adresse: ${pair.baseToken.address}
    D√©cimales: ${baseDecimals}
    Type: ${baseDecimals === 6 ? 'Standard (6)' : baseDecimals === 9 ? 'Pr√©cision (9)' : 'Personnalis√© ('+baseDecimals+')'}`);

priceUpdateInterval = setInterval(async () => {
    try {
        if (pair.chainId !== 'solana') {
            throw new Error("Seul Solana est support√©");
        }

        <!-- // 1. V√©rification des param√®tres de base -->
			const baseTokenAddress = pair.baseToken.address;
		<!-- // D√©finition d‚Äôune variable globale -->
			window.currentTokenAddress = baseTokenAddress;
			console.log("Adresse du token depuis index.html :", window.currentTokenAddress);
			
        if (!baseTokenAddress || baseTokenAddress.length < 30) {
            throw new Error("Adresse du token invalide");
        }
		
		// 2. Configuration des d√©cimales
        const baseDecimals = decimalsCache.get(baseTokenAddress) || 9;
		console.debug(`Calcul prix pour ${pair.baseToken.symbol} (${baseDecimals}d)`);
        const quoteDecimals = 6; // USDC
        const amountIn = Math.pow(10, baseDecimals); // 1 token entier

        // 3. Construction de la requ√™te avec v√©rification
        const url = new URL("https://lite-api.jup.ag/swap/v1/quote");
        const params = {
            inputMint: baseTokenAddress,
            outputMint: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
            amount: amountIn.toString(),
            slippageBps: "50",
            restrictIntermediateTokens: "true"
        };

        Object.entries(params).forEach(([key, value]) => {
            url.searchParams.append(key, value);
        });

        console.log("Requ√™te envoy√©e √† Jupiter:", url.toString()); // Debug

        // 4. Requ√™te avec timeout
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000);
        
        const response = await fetch(url.toString(), {
            signal: controller.signal
        });
        clearTimeout(timeoutId);

        if (!response.ok) {
            throw new Error(`Erreur HTTP ${response.status}`);
        }

        const data = await response.json();
        console.log("R√©ponse compl√®te de l'API Jupiter:", data); // Debug

        // 5. Validation stricte de la r√©ponse
        if (!data?.outAmount || isNaN(data.outAmount) || data.outAmount <= 0) {
            throw new Error("R√©ponse API invalide: outAmount manquant ou nul");
        }

        // 6. Calcul PR√âCIS pour 0.001 token
        const priceFor1Token = parseFloat(data.outAmount) / (10 ** quoteDecimals); // Prix pour 1 token en USDC
        const priceFor001Token = priceFor1Token * 0.001; // Prix pour 0.001 token

        if (priceFor001Token <= 0.000001) { // Seuil minimal r√©aliste ajust√©
            throw new Error(`Prix trop bas (${priceFor001Token}), probablement erron√©`);
        }

        // 7. Formatage final avec 7 d√©cimales
        const formattedPrice = priceFor001Token.toLocaleString('en', {
            minimumFractionDigits: 6,
            maximumFractionDigits: 6
        });

        // 8. Mise √† jour de l'UI
        document.getElementById("price").textContent = formattedPrice;
        document.getElementById("price-error").textContent = "";
        
        updateOHLC(priceFor001Token);
        priceHistory.push(priceFor001Token);
		
        // Garde un historique optimal pour le MACD (100-150 points)
        if (priceHistory.length > 150) {
            priceHistory = priceHistory.slice(-100); // Conserve les 100 derniers points
            console.debug(`Optimisation historique : 100 points conserv√©s`);
        }
		
        simulateTrading(priceFor001Token);

    } catch (err) {
        console.error("Erreur d√©taill√©e:", err);
        document.getElementById("price-error").textContent = 
            `Erreur: ${err.message.replace("Error: ", "")}`;
        
        // On conserve l'ancien prix au lieu de mettre 0
        if (!document.getElementById("price").textContent) {
            document.getElementById("price").textContent = "0.0000000";
        }
    }
	
}, 1500);

    }

  
   async function sendTelegramMessage(message) {
  try {
    console.log("Envoi vers Telegram :", message);
    
    const response = await fetch('/sendTelegram', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ 
        text: message,
        // Optionnel : m√©tadonn√©es suppl√©mentaires
        timestamp: new Date().toISOString(),
        source: "trading-bot"
      })
    });

    const result = await response.json();
    
    if (!response.ok || result.status !== 'success') {
      throw new Error(result.error || "√âchec de l'envoi");
    }
    
    console.log("‚úÖ Message envoy√©. ID:", result.message_id);
    return result.message_id; // Vous pouvez utiliser cet ID pour suivre le message
  
  } catch (e) {
    console.error("‚ùå √âchec de l'envoi :", e);
    // Optionnel : afficher une notification √† l'utilisateur
    showErrorNotification(e.message);
    throw e; // Propage l'erreur si n√©cessaire
  }
}


// Fonctions utilitaires
function calculateSimpleVolatility(prices, lookback = 20) {
  const actualLookback = Math.min(lookback, prices.length - 1);
  if (actualLookback < 2) return 0.02;
  
  let sumChanges = 0;
  for (let i = 1; i <= actualLookback; i++) {
    sumChanges += Math.abs(prices[i] - prices[i-1]) / prices[i-1];
  }
  return sumChanges / actualLookback;
}

function linearRegressionSlope(prices) {
  const n = prices.length;
  if (n < 2) return 0;
  
  let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
  
  for (let i = 0; i < n; i++) {
    sumX += i;
    sumY += prices[i];
    sumXY += i * prices[i];
    sumXX += i * i;
  }
  
  const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
  return slope / n; // Normalisation par le nombre de points
}

// Variable globale
let lastDoubleBottomIndex = -1;
let pauseUntil = 0; // Timestamp jusqu'√† quand la d√©tection est en pause


function simulateTrading(price) {

if (typeof detectTripleBottom !== 'function') {
  console.error('Fonction detectTripleBottom non disponible');
  return;
}

// 1. V√©rification de la pause
  const now = Date.now();
  if (now < pauseUntil) {
    console.log(`‚è∏ D√©tection en pause jusqu'√† ${new Date(pauseUntil).toLocaleTimeString()}`);
    return;
  }

 
  // 1. V√©rification initiale stricte
  if (!Array.isArray(priceHistory)) {
    console.error('R√©initialisation de priceHistory');
    priceHistory = [];
    return;
  }
  
  const logDiv = document.getElementById("token-info");
  const minDetectionDelay = 60000; // D√©lai minimum entre 2 d√©tections (1 minute )
  

  // V√©rification des conditions de base pour un nouveau trade
  if (!activeTrade && priceHistory.length >= 5 && stopLossCounter < config.maxSL) {
    // Anti-d√©tection trop fr√©quente
    // V√©rifie soit le d√©lai de d√©tection, soit le d√©lai apr√®s trade
	if (now - lastDetectionTime < minDetectionDelay || now - lastTradeTime < minTradeDelay) {
    return;
	}

    let doubleBottomPrice = null;
    let doubleBottomIndex = -1;
	let tripleBottomPrice = null; // <-- Ajoutez cette ligne
	let tripleBottomResult = null;
	let lastFVGIndex = -1; // <-- ajouter cette ligne
	
	    
		
		
		
    // =============================================
    // 1. CALCUL DE VOLATILIT√â POUR LE SEUIL DE TOL√âRANCE
    // =============================================
    const volatility = calculateSimpleVolatility(priceHistory);
    // Tolerance dynamique (1.5x la volatilit√©) entre 1% et 5%
    const tolerance = Math.min(0.05, Math.max(0.01, volatility * 1.5));
	
	// =============================================
	// 1B. D√âTECTION DE VARIATION POSITIVE (5 MIN)
	// =============================================
	let positiveMove = null;
	if (config.detectPositiveVariation) {
    console.log("üîç D√©tection de variation positive activ√©e sur 5 min...");
    console.log("üìä Historique de prix re√ßu :", priceHistory);

    // Analyse sur les 5 derni√®res minutes, avec 0% comme seuil minimum
    positiveMove = window.detectPositiveVariation(priceHistory, 5, 0);

    if (!positiveMove) {
        console.log("‚ùå Aucune variation positive d√©tect√©e sur les 5 derni√®res minutes. Signal ignor√©.");
        return;
    } else {
        console.log("üìà Variation positive d√©tect√©e :", positiveMove);
		}
	}

// =============================================
// 2A. D√âTECTION DU DOUBLE BOTTOM AVEC IA (ASYNC NON-BLOQUANTE)
// =============================================
if (config.detectDoubleBottom) {
    console.log("üîç Recherche de Double Bottom avec IA (activ√©e)");

    // 1. D√©tection technique de base (votre fonction existante)
    const doubleBottomResult = window.detectDoubleBottom(
        priceHistory,
        tolerance,
        price,
        lastDoubleBottomIndex
    );

    if (doubleBottomResult) {
        console.log("‚úÖ Pattern technique d√©tect√©", {
            minValue: doubleBottomResult.minValue,
            confirmationLevel: doubleBottomResult.confirmationLevel,
            index: doubleBottomResult.index
        });

        // 2. V√©rification par l'IA seulement si le prix d√©passe le niveau de confirmation
        if (price > doubleBottomResult.confirmationLevel) {
            console.log("üìà Prix au-dessus du niveau de confirmation - V√©rification IA (async)...");

            // Appel IA en arri√®re-plan
            const iaConfirmer = new DoubleBottomConfirmer();
            iaConfirmer.confirmPattern(
                priceHistory.slice(doubleBottomResult.index),
                selectedPair?.baseToken?.address || null
            )
            .then(iaAnalysis => {
                console.log("üß† R√©sultat IA:", iaAnalysis);

                if (iaAnalysis.confirmed) {
                    console.log("üéØ Double bottom confirm√© par IA", {
                        confidence: iaAnalysis.confidence,
                        recommendedSl: iaAnalysis.recommendedSl
                    });

                    doubleBottomPrice = doubleBottomResult.minValue;
                    doubleBottomIndex = doubleBottomResult.index;
                    lastDetectionTime = Date.now();

                    // Ajouter les insights IA √† l'interface
                    displayAIConfirmation(iaAnalysis);

                } else {
                    console.log("‚ùå Rejet√© par IA:", iaAnalysis.details.reason);
                    addNotification(`IA a rejet√© le pattern: ${iaAnalysis.details.reason}`);
                }
            })
            .catch(err => {
                console.error("Erreur IA:", err);
                addNotification(`Erreur lors de l'analyse IA : ${err.message}`);
            });

            // Ici, la recherche de tokens continue imm√©diatement
        }
    }
}

	
	
	
	
		
	<!-- // ================================================ -->
	<!-- // 2B1. D√âTECTION BULLISH FVG SOUS NIVEAU FIBONACCI -->
	<!-- // ================================================ -->
		let bullishFVGResult = null;
		if (config.detectBullishFVGUnderFib && typeof window.detectBullishFVGUnderFib === 'function') {
			console.log("üîç Recherche de Bullish FVG sous Fibonacci (activ√©e)");
    
			bullishFVGResult = window.detectBullishFVGUnderFib(
			priceHistory,
			50,           // lookback par d√©faut
			0.5,          // ratio Fibonacci par d√©faut
			price,        // prix actuel
			lastFVGIndex  // derni√®re d√©tection FVG pour √©viter doublons
		);

		if (bullishFVGResult) {
			console.log("‚úÖ %cBullish FVG d√©tect√©", "color: blue", {
            low: bullishFVGResult.low.toFixed(6),
            high: bullishFVGResult.high.toFixed(6),
            fibLevel: bullishFVGResult.fibLevel.toFixed(6),
            entryPrice: bullishFVGResult.entryPrice.toFixed(6),
            confirmationLevel: bullishFVGResult.confirmationLevel.toFixed(6)
        });

        if (price > bullishFVGResult.confirmationLevel) {
            console.log("üìà %cPrix actuel AU-DESSUS du niveau de confirmation FVG", "color: green");
            lastDetectionTime = Date.now();
        } else {
            console.log("üìâ %cPrix actuel EN-DESSOUS du niveau de confirmation FVG", "color: red");
        }

        // Mettre √† jour l'index de derni√®re d√©tection pour √©viter doublons
        lastFVGIndex = bullishFVGResult.index;
		} else {
        console.log("‚ùå %cAucun Bullish FVG d√©tect√© sous Fibonacci", "color: grey");
		}
	}

		
	// =============================================
    // 2C. D√âTECTION BULLISH RECTANGLE (SI ACTIV√â)
    // =============================================
        let rectangleResult = null;
        if (config.detectBullishRectangle) {
            console.log("üîç Recherche de Bullish Rectangle (activ√©e)");
            
            // DEBUG Bullish Rectangle - Affichage des prix r√©cents
            const lastPrices = priceHistory.slice(-10).map(p => p.toFixed(6));
            console.log("üìä Prix (10 derniers):", lastPrices.join(" ‚Üí "));
            
            rectangleResult = window.detectBullishRectangle(
                priceHistory,
                tolerance,
                price
            );

            if (rectangleResult) {
                console.log("‚úÖ %cBullish Rectangle d√©tect√©", "color: orange", {
                    upperBound: rectangleResult.upperBound,
                    lowerBound: rectangleResult.lowerBound,
                    confirmationLevel: rectangleResult.confirmationLevel
                });
                
                // DEBUG - Affichage des niveaux cl√©s
                console.log("üìè Niveaux:", 
                    `R√©sistance: ${rectangleResult.upperBound.toFixed(6)} | ` +
                    `Support: ${rectangleResult.lowerBound.toFixed(6)} | ` +
                    `Confirmation: ${rectangleResult.confirmationLevel.toFixed(6)}`
                );
                
                if (price > rectangleResult.confirmationLevel) {
                    console.log("üìà %cPrix actuel AU-DESSUS du niveau de confirmation", "color: green");
                    lastDetectionTime = Date.now();
                } else {
                    console.log("üìâ %cPrix actuel EN-DESSOUS du niveau de confirmation", "color: red");
                }
            } else {
                console.log("‚ùå %cAucun Bullish Rectangle d√©tect√©", "color: grey");
            }
		}
   
    // =============================================
    // 2D. D√âTECTION COMBO INVERTED HEAD&SHOULDERS + DOUBLE BOTTOM (SI ACTIV√â)
    // =============================================
		
	const comboDetected = config.detectInvertedHSDoubleBottomCombo
    ? window.detectInvertedHSDoubleBottomCombo(priceHistory, 0.03, price) //Votre tableau de prix historiques;Une tol√©rance de 3% pour les niveaux de prix;Le prix actuel
    : null;
	
	if (config.detectInvertedHSDoubleBottomCombo) {
		//DEBUG InvertedHeadShouldersDoubleBottomCombo
		// 1. Affiche les prix avec fl√®ches directionnelles (‚Üó ‚Üò)
		const lastPrices = priceHistory.slice(-10).map(p => p.toFixed(6));
		console.log("V√©rification des conditions pour Combo Inverted HS&DB");
		console.log("üìä Prix (10 derniers):", lastPrices.join(" ‚Üí "));
		// 2. D√©tection H&S invers√© avec ic√¥ne visuel
		const hsResult = window.detectInvertedHeadAndShoulders(priceHistory);
		console.log(
		hsResult ? "‚úÖ %cH&S Invers√© D√âTECT√â" : "‚ùå %cAucun H&S Invers√©", 
		hsResult ? "color: green" : "color: grey",
		hsResult || ""
		);
		// 3. D√©tection Double Bottom avec couleur conditionnelle
		const dbResult = window.detectDoubleBottom(priceHistory);
		console.log(
		dbResult ? "‚úÖ %cDouble Bottom D√âTECT√â" : "‚ùå %cAucun Double Bottom", 
		dbResult ? "color: blue" : "color: grey",
		dbResult || ""
		);
	}	
		console.groupEnd();
		
	<!-- // ================================================================= -->
    <!-- // 2E. D√âTECTION COMBO DOUBLE BOTTOM + BULLISH RECTANGLE (SI ACTIV√â) -->
    <!-- // ================================================================= -->
    const dbBrComboDetected = config.detectDoubleBottomBullishRectangleCombo
        ? window.detectDoubleBottomBullishRectangleCombo(priceHistory, 0.025, price)
        : null;

    if (config.detectDoubleBottomBullishRectangleCombo) {
        console.log("üîç Recherche de Combo Double Bottom + Bullish Rectangle");

        // DEBUG - Affichage des prix r√©cents
        const lastPrices = priceHistory.slice(-15).map(p => p.toFixed(6));
        console.log("üìä Prix (15 derniers):", lastPrices.join(" ‚Üí "));

        // DEBUG - D√©tection s√©par√©e des composants
        const dbResult = window.detectDoubleBottom(
            priceHistory.slice(0, Math.floor(priceHistory.length / 2)),
            0.03
        );
        console.log(
            dbResult ? "‚úÖ %cDouble Bottom D√âTECT√â (premi√®re partie)" : "‚ùå %cAucun Double Bottom", 
            dbResult ? "color: blue" : "color: grey",
            dbResult || ""
        );

        const brResult = window.detectBullishRectangle(
            priceHistory.slice(Math.floor(priceHistory.length / 2)),
            0.025,
            price
        );
        console.log(
            brResult ? "‚úÖ %cBullish Rectangle D√âTECT√â (seconde partie)" : "‚ùå %cAucun Bullish Rectangle", 
            brResult ? "color: orange" : "color: grey",
            brResult || ""
        );

        // DEBUG - Affichage des r√©sultats du combo
        if (dbBrComboDetected) {
            console.log("üî• %cCOMBO D√âTECT√â: Double Bottom + Bullish Rectangle", "color: purple; font-weight: bold", {
                confirmationLevel: dbBrComboDetected.confirmationLevel,
                doubleBottom: dbBrComboDetected.components.doubleBottom,
                bullishRectangle: dbBrComboDetected.components.bullishRectangle
            });

            console.log("üìè Niveaux cl√©s:", 
                `Confirmation: ${dbBrComboDetected.confirmationLevel.toFixed(6)} | ` +
                `DB Neckline: ${dbBrComboDetected.components.doubleBottom.confirmationLevel.toFixed(6)} | ` +
                `BR Upper: ${dbBrComboDetected.components.bullishRectangle.upperBound.toFixed(6)}`
            );

            if (price > dbBrComboDetected.confirmationLevel) {
                console.log("üöÄ %cPrix AU-DESSUS du niveau de confirmation COMBO", "color: green; font-weight: bold");
                lastDetectionTime = Date.now();
            } else {
                console.log("‚è≥ %cPrix EN-DESSOUS du niveau de confirmation COMBO", "color: orange");
            }
        } else {
            console.log("‚ùå %cAucun combo Double Bottom + Bullish Rectangle valide", "color: grey");
        }
    }	
	
	// =============================================
    // 2B. D√âTECTION TRIPLE BOTTOM PRIX TEMPS REEL
    // =============================================
		const closes = ohlcSeries.map(c => c.close);
		window.closes = closes;  // maintenant accessibles depuis l‚Äôext√©rieur
		const timeframeSelect = document.getElementById("timeframe-select");
		const timeframe = timeframeSelect ? timeframeSelect.value : "1"; 
		const statusEl = document.getElementById("triple-bottom-status");
		// Dernier prix connu pour la d√©tection
		const price = closes[closes.length - 1];
		window.price = price;    // idem pour le dernier prix
		
		console.log(`üîç Recherche de Triple Bottom sur un Timeframe ${timeframe}m activ√©e
		10 bougies n√©cessaire pour commencer la d√©tection Triple Bottom ${closes.length}/10)`);
        if (closes.length >= 10 && config.detectTripleBottom && typeof window.detectTripleBottom === 'function') {
			statusEl.textContent = `üîç D√©tection Triple Bottom activ√© (${closes.length}/10 bougies dispo, TF: ${window.selectedTimeframe}m)`;
		
          
            tripleBottomResult = window.detectTripleBottom(
                closes, <!-- utilise les closes des bougies -->
                tolerance, 
                price, 
                lastDoubleBottomIndex
            );

            if (tripleBottomResult) {
				statusEl.textContent = `‚úÖ Triple Bottom d√©tect√© √† ${price.toFixed(4)} (TF: ${window.selectedTimeframe}m)`;
                console.log("‚úÖ Triple Bottom d√©tect√©", tripleBottomResult);
                lastDetectionTime = Date.now();
            }
		} 	else {
				const missing = 10 - closes.length;
				statusEl.textContent = `‚è≥ 10 bougies n√©cessaire pour commencer la d√©tection (${closes.length}/10)`;
				}
      
      
      <!-- // ============================================= -->
      <!-- // 4. EX√âCUTION DU TRADE SI TOUT EST VALIDE      -->
      <!-- // ============================================= -->
      // Modification ici - on v√©rifie si les confirmations sont valides selon les param√®tres
 
	  
	
<!-- // DETERMINER LE PATTERN UTILSE -->
let activePattern = null;
if (comboDetected && price > comboDetected.confirmationLevel) {
    activePattern = {
        type: "combo",
        entry: comboDetected.confirmationLevel,
        name: "Inverted H&S + Double Bottom"
        };
} else if (rectangleResult && price > rectangleResult.confirmationLevel) {
            activePattern = {
                type: "rectangle",
                entry: rectangleResult.confirmationLevel,
                name: "Bullish Rectangle",
                bounds: {
                    upper: rectangleResult.upperBound,
                    lower: rectangleResult.lowerBound
                }
            };
} else if ((window.tripleBottomResult && window.tripleBottomResult.entryPrice != null) || 
           (tripleBottomResult && tripleBottomResult.entryPrice != null)) {
    const tb = (window.tripleBottomResult && window.tripleBottomResult.entryPrice != null) 
               ? window.tripleBottomResult 
               : tripleBottomResult;
    activePattern = {
        type: "triple",
        entry: tb.entryPrice,
        name: "Triple Bottom",
        minValue: tb.minValue,
    };
} else if (doubleBottomPrice !== null) {
    activePattern = {
        type: "double",
        entry: doubleBottomPrice,
        name: "Double Bottom"
        };
}

	<!-- //	EXECUTION SI VALIDATION MACD/RSI OK  -->
    if (activePattern) {
		const time = new Date().toLocaleTimeString();
		   
		console.log("‚úÖ ACTIVE PATTERN trouv√© :", activePattern);
		if (!activePattern.entry || isNaN(activePattern.entry)) {
        console.error("‚ùå Entry invalide :", activePattern.entry);
    }
		
		<!-- // AFFCICHER LE SIGNAL SUR LA PAGE WEB AVEC/SANS MACD FFCC00 D4AF37 F1C40F FFD700 -->
			logDiv.innerHTML += `
              <div style="margin-top:10px; padding:10px; background:#F1C40F; border-radius:5px;"> 
                üïì <strong>${activePattern.name} d√©tect√©${config.useMACD ? " + MACD" : ""}${config.useRSI ? " + RSI" : ""}</strong> √† <strong>${time}</strong><br>
                üéØ <strong>Entr√©e √† ${activePattern.entry.toFixed(6)}$</strong>
				${config.useRSI ? `<br>üìä <strong>RSI: ${rsiValue?.toFixed(2) || 'N/A'}</strong>` : ''}
			  </div>`;
			  	
    
		<!-- //GESTION TAKE PROFIT, STOP LOSS, TRAILING -->
		activeTrade = {
        entryPrice: activePattern.entry,  // Utilisation de activePattern.entry
        tp: activePattern.entry * (1 + config.tp / 100),
        sl: activePattern.entry * (1 - config.sl / 100),
        trailing: activePattern.entry * (1 + (config.tp - config.trailing) / 100),
        highest: activePattern.entry,
        pattern: activePattern.type  // "combo", "triple" ou "double"
		};

		// Variable accessible globalement
		window.activeTrade = activeTrade;
		console.log("üí∞ ACTIVE TRADE cr√©√© :", window.activeTrade);

		// ‚ñº‚ñº‚ñº Mise √† jour de l'index ‚ñº‚ñº‚ñº
		lastDoubleBottomIndex = activePattern.type === "triple" && comboDetected?.components?.doubleBottom?.index 
                          ? comboDetected.components.doubleBottom.index 
                          : doubleBottomIndex;
						 				  
  		
<!-- // ‚ûï APPEL AU BACKEND POUR EXECUTER LE TRADE -->
  fetch("/trade", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    chain: "solana",
    pair: selectedPair.baseToken.address, // ou dynamic depuis selectedPair.baseToken.address
    walletId: "mcadntmr5gxofz",     // ton wallet
    type: "buy",
    amountOrPercent: config.tradeAmount || 0.00,
    customFeeAndTip: false,
    priorityFee: 0.00005,
    gasFeeDelta: 0,
    maxFeePerGas: 0,
    jitoEnabled: false,
    jitoTip: 0,
    maxSlippage: 0.02, //en pourcentage
    concurrentNodes: 2,
    retries: 1,
    migrateSellPercent: 0,
    minDevSellPercent: 0,
    devSellPercent: 0,
    stopEarnPercent: null,
    stopLossPercent: 0.25,
    stopEarnGroup: null,
    stopLossGroup: null,
    trailingStopGroup: null, // suit le prix √† la hausse, mais vend si √ßa retombe d‚Äôun certain seuil (ex: -20%).
    pnlOrderExpireDelta: 86400000,
    pnlOrderExpireExecute: false,
    pnlOrderUseMidPrice: false,
    pnlCustomConfigEnabled: false,
    pnlCustomConfig: {
      customFeeAndTip: false,
      priorityFee: 0.00005,
      gasFeeDelta: 0,
      maxFeePerGas: 0,
      jitoEnabled: false,
      jitoTip: 0,
      maxSlippage: 0.025,
      concurrentNodes: 2,
      retries: 1
    }
  })
})
  .then(res => res.json())
  .then(data => {
    if (data.success) {
      logDiv.innerHTML += `<div style="color:green;">‚úÖ Trade ex√©cut√© avec succ√®s</div>`;
      console.log("‚úÖ Trade envoy√© √† l'API DBotX", data.result);
    } else {
      logDiv.innerHTML += `<div style="color:red;"><strong>‚ùå Erreur lors du trade d'achat : ${data.error}</strong></div>`;
      console.error("‚ùå Erreur trade DBotX :", data.error);
    }
  })
  .catch(err => {
    logDiv.innerHTML += `<div style="color:red;">‚ùå √âchec de la requ√™te API DBotX</div>`;
    console.error("‚ùå Exception API :", err);
  });

			
          }
        }
      }

      // Gestion de la position existante (TP/SL)
      if (activeTrade) {
		closes[closes.length - 1] = window.price;
		const lastPrice = window.price || closes[closes.length - 1]; // prix actuel en temps r√©el
        const { entryPrice, tp, sl, trailing, highest } = activeTrade;
        const time = new Date().toLocaleTimeString();

		console.log("üìä Check Stop Loss", { lastPrice, sl, entryPrice });
        if (lastPrice <= sl) {
		 const lossPercentage = ((entryPrice - lastPrice) / entryPrice * 100).toFixed(2);
		 const tradeperdant = 
		 `üî¥ TRADE PERDANT ‚ùå Stop Loss touch√© √† ${time}\n` +
		 `üí∞ Vente √† ${lastPrice.toFixed(6)} - Perte: ${lossPercentage}%$\n` +
		 `üî† Symbole : ${selectedPair.baseToken.symbol}\n` +
		 `üìå Adresse : ${selectedPair.baseToken.address}%`;
		 
		 // V√©rifier si l'erreur d'achat existe
			const hasPurchaseError = document.getElementById('token-info').textContent.includes('Aucun tradeId re√ßu');

		//	Verification de la condition	
			console.log("üî• STOP LOSS d√©clench√© !", { lastPrice, sl, entryPrice });	
			
		 // 1. On affiche toujours le message de Vente
		  logDiv.innerHTML += `
		  <div style="margin-top:10px; padding:10px; background:#E74C3C; border-radius:5px;"> 
		        ‚ùå <strong>Stop Loss touch√© √† ${lastPrice.toFixed(6)}$ (${time})</strong><br>
				üí∞ <strong>Perte: ${lossPercentage}%</strong>
			  </div>
			  <div style="color:red;">
			    ‚ùå <strong>${hasPurchaseError ? 'Trade non ex√©cut√© (Trade simul√©)' : 'Trade execut√©'}</strong>
				</div>`;
				
		
		  
			// Supprimer la position ou r√©initialiser activeTrade
			activeTrade = null;
			
		  if (!hasPurchaseError) {
		  			// ‚ûï Appel √† ton backend pour ex√©cuter le trade perdant
  fetch("/trade", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    chain: "solana",
    pair: selectedPair.baseToken.address, // ou dynamic depuis selectedPair.baseToken.address
    walletId: "mcadntmr5gxofz",     // ton wallet
    type: "sell",
    amountOrPercent: 1,
    customFeeAndTip: false,
    priorityFee: 0.00005,
    gasFeeDelta: 0,
    maxFeePerGas: 0,
    jitoEnabled: false,
    jitoTip: 0,
    maxSlippage: 0.05, //en pourcentage
    concurrentNodes: 2,
    retries: 1,
    migrateSellPercent: 0,
    minDevSellPercent: 0,
    devSellPercent: 0,
    stopEarnPercent: null,
    stopLossPercent: null,
    stopEarnGroup: null,
    stopLossGroup: null,
    trailingStopGroup: null, // suit le prix √† la hausse, mais vend si √ßa retombe d‚Äôun certain seuil (ex: -20%).
    pnlOrderExpireDelta: 86400000,
    pnlOrderExpireExecute: false,
    pnlOrderUseMidPrice: false,
    pnlCustomConfigEnabled: false,
    pnlCustomConfig: {
      customFeeAndTip: false,
      priorityFee: 0.00005,
      gasFeeDelta: 0,
      maxFeePerGas: 0,
      jitoEnabled: false,
      jitoTip: 0,
      maxSlippage: 0.02,
      concurrentNodes: 2,
      retries: 1
    }
  })
})
}

                    
          //addNotification(message);
          sendTelegramMessage(tradeperdant);
		  activeTrade = null;
          stopLossCounter++;
		  lastTradeTime = Date.now();

          if (stopLossCounter >= config.maxSL) {
		  // R√©cup√©ration S√âCURIS√âE des infos
			const symbol = selectedPair?.baseToken?.symbol || "Token inconnu";
			const address = selectedPair?.baseToken?.address || "Adresse inconnue"
		    const maxSlMessage = 
			`‚ö´ ARRET DETECTION\n` +
			`üö´ Nombre maximum de Stop Loss atteint (${config.maxSL})\n` +
			`üí∞ Vente √† ${price.toFixed(6)} - Perte: ${lossPercentage}%$\n` +
			`üî† Symbole : ${symbol}\n` +
			`üìå Adresse : ${address}`;
			
			// V√©rifier si l'erreur d'achat existe
			const hasPurchaseError = document.getElementById('token-info').textContent.includes('Aucun tradeId re√ßu');
			
			// 1. On affiche toujours le message de Vente
		    logDiv.innerHTML += `<p style="color:gray;">üö´ Nombre maximum de Stop Loss atteint (${config.maxSL}). Arr√™t de la d√©tection.</p>`;
            //addNotification(maxSlMessage);
            sendTelegramMessage(maxSlMessage);
			
		if (!hasPurchaseError) {	
					// ‚ûï Appel √† ton backend pour ex√©cuter le trade
  fetch("/trade", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    chain: "solana",
    pair: selectedPair.baseToken.address, // ou dynamic depuis selectedPair.baseToken.address
    walletId: "mcadntmr5gxofz",     // ton wallet
    type: "sell",
    amountOrPercent: 1,
    customFeeAndTip: false,
    priorityFee: 0.00005,
    gasFeeDelta: 0,
    maxFeePerGas: 0,
    jitoEnabled: false,
    jitoTip: 0,
    maxSlippage: 0.05, //en pourcentage
    concurrentNodes: 2,
    retries: 1,
    migrateSellPercent: 0,
    minDevSellPercent: 0,
    devSellPercent: 0,
    stopEarnPercent: null,
    stopLossPercent: null,
    stopEarnGroup: null,
    stopLossGroup: null,
    trailingStopGroup: null, // suit le prix √† la hausse, mais vend si √ßa retombe d‚Äôun certain seuil (ex: -20%).
    pnlOrderExpireDelta: 86400000,
    pnlOrderExpireExecute: false,
    pnlOrderUseMidPrice: false,
    pnlCustomConfigEnabled: false,
    pnlCustomConfig: {
      customFeeAndTip: false,
      priorityFee: 0.00005,
      gasFeeDelta: 0,
      maxFeePerGas: 0,
      jitoEnabled: false,
      jitoTip: 0,
      maxSlippage: 0.02,
      concurrentNodes: 2,
      retries: 1
    }
  })
})
  .then(res => res.json())
  .then(data => {
    if (data.success) {
      logDiv.innerHTML += `<div style="color:green;">‚úÖ Trade ex√©cut√© avec succ√®s</div>`;
      console.log("‚úÖ Trade envoy√© √† l'API DBotX", data.result);
    } else {
      logDiv.innerHTML += `<div style="color:red;">‚ùå Erreur lors du trade : ${data.error}</div>`;
      console.error("‚ùå Erreur trade DBotX :", data.error);
    }
  })
  .catch(err => {
    logDiv.innerHTML += `<div style="color:red;">‚ùå √âchec de la requ√™te API DBotX</div>`;
    console.error("‚ùå Exception API :", err);
  });
  
 }
			
          }
        } else if (price >= tp) {
          activeTrade.highest = Math.max(highest, price);
          const trailingStop = highest * (1 - config.trailing / 100);

          if (price < trailingStop) {
		   const winPercentage = ((price - entryPrice) / entryPrice * 100).toFixed(2);
		   // R√©cup√©ration S√âCURIS√âE des infos
			const symbol = selectedPair?.baseToken?.symbol || "Token inconnu";
			const address = selectedPair?.baseToken?.address || "Adresse inconnue"
			
			// V√©rifier si l'erreur d'achat existe
			const hasPurchaseError = document.getElementById('token-info').textContent.includes('Aucun tradeId re√ßu');
			
			// 1. On affiche toujours le message de trailing
		   logDiv.innerHTML += `
		   <div style="margin-top:10px; padding:10px; background:#1E8449; border-radius:5px;"> 
                üîÑ <strong>${hasPurchaseError ? 'Trailing Stop simul√©' : 'Trailing Stop activ√©'} √† ${price.toFixed(6)}$ (${time})</strong><br>
				üí∞ <strong>${hasPurchaseError ? 'Gain simul√©' : 'Gain'}: ${winPercentage}%</strong>
			  </div>
			  <div style="color:red;">
			    <strong>${hasPurchaseError ? '‚ùå Trade non ex√©cut√© (Trade simul√©)' : ''}</strong>
				</div>`;
					   
		    // Ajout de la pause de 5 minutes (300000 ms)
			pauseUntil = now + 300000;
			console.log(`‚è∏ Mise en pause de la d√©tection pour 5 minutes (jusqu'√† ${new Date(pauseUntil).toLocaleTimeString()})`);
			
			
            const tradegagnant = 
			`üü¢ TRADE GAGNANT\n` +
			`üîÑ Trailing Stop activ√© √† ${time}\n` +
			`üí∞ Vente √† ${price.toFixed(6)}$ - Gain : ${winPercentage}\n` +
			`üî† Symbole : ${symbol}\n` +
			`üìå Adresse : ${address}`;
			
            //addNotification(message);
            sendTelegramMessage(tradegagnant);
            activeTrade = null;
			lastTradeTime = Date.now();
			
			if (!hasPurchaseError) {
			// ‚ûï Appel √† ton backend pour ex√©cuter le trade
  fetch("/trade", {
  method: "POST",
  headers: { "Content-Type": "application/json" },
  body: JSON.stringify({
    chain: "solana",
    pair: selectedPair.baseToken.address, // ou dynamic depuis selectedPair.baseToken.address
    walletId: "mcadntmr5gxofz",     // ton wallet
    type: "sell",
    amountOrPercent: 1,
    customFeeAndTip: false,
    priorityFee: 0.00005,
    gasFeeDelta: 0,
    maxFeePerGas: 0,
    jitoEnabled: false,
    jitoTip: 0,
    maxSlippage: 0.05, //en pourcentage
    concurrentNodes: 2,
    retries: 1,
    migrateSellPercent: 0,
    minDevSellPercent: 0,
    devSellPercent: 0,
    stopEarnPercent: null,
    stopLossPercent: null,
    stopEarnGroup: null,
    stopLossGroup: null,
    trailingStopGroup: null, // suit le prix √† la hausse, mais vend si √ßa retombe d‚Äôun certain seuil (ex: -20%).
    pnlOrderExpireDelta: 86400000,
    pnlOrderExpireExecute: false,
    pnlOrderUseMidPrice: false,
    pnlCustomConfigEnabled: false,
    pnlCustomConfig: {
      customFeeAndTip: false,
      priorityFee: 0.00005,
      gasFeeDelta: 0,
      maxFeePerGas: 0,
      jitoEnabled: false,
      jitoTip: 0,
      maxSlippage: 0.02,
      concurrentNodes: 2,
      retries: 1
    }
  })
})
  .then(res => res.json())
  .then(data => {
    if (data.success) {
      logDiv.innerHTML += `<div style="color:green;">‚úÖ Trade ex√©cut√© avec succ√®s</div>`;
      console.log("‚úÖ Trade envoy√© √† l'API DBotX", data.result);
    } else {
      logDiv.innerHTML += `<div style="color:red;">‚ùå Erreur lors du trade : ${data.error}</div>`;
      console.error("‚ùå Erreur trade DBotX :", data.error);
    }
  })
  .catch(err => {
    logDiv.innerHTML += `<div style="color:red;">‚ùå √âchec de la requ√™te API DBotX</div>`;
    console.error("‚ùå Exception API :", err);
  });
  }
  
          }
        }
      }
    
	
	
	//Bouton Simulation Achat
	  document.getElementById("simulate-detection").addEventListener("click", () => {
  
  // 0. D√©clarer 'now' au d√©but de la fonction
    const now = Date.now();
   
  // 1. R√©initialisation COMPL√àTE en douceur
    lastDetectionTime = 0;
    stopLossCounter = 0;
    lastDoubleBottomIndex = -1;
    pauseUntil = 0;
    activeTrade = null;

    // 2. S√©quence MAGIQUE pour votre algorithme existant
    const basePrice = 0.000230;
    const magicSequence = [
        // Structure parfaite pour votre d√©tection :
        basePrice * 1.10,  // [0] Haut initial
        basePrice * 1.05,  // [1] p0 (avant p1)
        basePrice * 0.92,  // [2] p1 - Premier creux
        basePrice * 0.90,  // [3] p2 - Point le PLUS BAS
        basePrice * 0.93,  // [4] p3 - Second creux
        basePrice * 0.95,  // [5] p4 (apr√®s p2)
        basePrice * 1.08   // [6] Prix actuel (breakout)
    ];

    // 3. Injection en douceur
    priceHistory = [...magicSequence];
    const currentPrice = magicSequence[6];
    document.getElementById("price").textContent = currentPrice.toFixed(6);

    // 4. V√©rification visuelle (sans console.log)
    const visualDebug = `
        <div style="margin:10px;padding:10px;background:#113311;border-radius:5px;">
            <strong>‚úÖ S√©quence optimis√©e pr√™te</strong>
            <div style="display:flex; margin-top:8px;">
                <div style="flex:1;">
                    <div>Creux 1: ${magicSequence[2].toFixed(6)}</div>
                    <div>Point bas: ${magicSequence[3].toFixed(6)}</div>
                    <div>Creux 2: ${magicSequence[4].toFixed(6)}</div>
                </div>
                <div style="flex:1;">
                    <div>Structure: Valide</div>
                    <div>Breakout: ${currentPrice.toFixed(6)}</div>
                    <div>D√©tection: Pr√™te</div>
                </div>
            </div>
        </div>`;
    document.getElementById("token-info").innerHTML += visualDebug;

    // 5. D√©clenchement en douceur apr√®s court d√©lai
    setTimeout(() => {
        simulateTrading(currentPrice);
        
        // V√©rification visuelle du r√©sultat
        setTimeout(() => {
            if (activeTrade) {
                document.getElementById("token-info").innerHTML += `
                    <div style="color:green;margin-top:5px;">
                        üéâ D√©tection r√©ussie √† ${currentPrice.toFixed(6)}
                    </div>`;
            } else {
                document.getElementById("token-info").innerHTML += `
                    <div style="color:gold;margin-top:5px;">
                        ‚ö†Ô∏è V√©rifiez les param√®tres de d√©tection
                    </div>`;
            }
        }, 300);
    }, 100);
});

//Bouton Simulation Trailing
document.getElementById("simulate-trailing").addEventListener("click", () => {
    if (!activeTrade) {
        alert("Aucun trade actif. Veuillez d'abord d√©tecter un signal d'achat.");
        return;
    }

    // Logique pour forcer le d√©clenchement du trailing stop existant
    const currentPrice = parseFloat(document.getElementById("price").textContent);
    const trailingStopLevel = activeTrade.highest * (1 - config.trailing / 100);
    
    // Modifie le dernier prix pour d√©clencher le trailing
    const triggerPrice = trailingStopLevel * 0.99; // Juste en dessous du seuil
    
    // Affiche les informations de debug
    console.log("[Trailing Stop Test] Activation forc√©e", {
        currentHighest: activeTrade.highest,
        trailingStopLevel: trailingStopLevel,
        triggerPrice: triggerPrice
    });

    // Ajoute un message dans l'interface
    const logDiv = document.getElementById("token-info");
    logDiv.innerHTML += `
        <div class="notification" style="background-color: #333300;">
            üß™ TEST TRAILING STOP: 
            Plus haut = ${activeTrade.highest.toFixed(6)}, 
            Seuil = ${trailingStopLevel.toFixed(6)}, 
            Prix simul√© = ${triggerPrice.toFixed(6)}
        </div>`;

    // Appelle la fonction existante avec le prix qui d√©clenche le trailing
    simulateTrading(triggerPrice);
});


 // Simulation Triple Bottom
document.getElementById("simulate-triple-bottom").addEventListener("click", () => {
    // Cr√©e des bougies fictives si besoin pour avoir au moins 10 closes
    window.ohlcSeries = window.ohlcSeries || [];
    while (window.ohlcSeries.length < 10) {
        const lastClose = window.ohlcSeries.length 
            ? window.ohlcSeries[window.ohlcSeries.length - 1].close 
            : 1.0;
        const newClose = lastClose * (1 + (Math.random() - 0.5) * 0.01);
        window.ohlcSeries.push({ open: newClose, high: newClose, low: newClose, close: newClose, timeSlot: window.ohlcSeries.length, timestamp: Date.now() });
    }

    // Mettre √† jour closes et price
    window.closes = window.ohlcSeries.map(c => c.close);
    window.price = window.closes[window.closes.length - 1];

    // Injecter le Triple Bottom
    window.tripleBottomResult = {
        pattern: "Triple Bottom",
        entryPrice: window.price,
        minValue: Math.min(...window.closes.slice(-3)),
        confirmationLevel: window.price,
        index: window.closes.length - 1,
        indices: [window.closes.length - 3, window.closes.length - 2, window.closes.length - 1]
    };
    console.log("‚úÖ Triple Bottom simul√© :", window.tripleBottomResult);

    // Cr√©er directement activeTrade pour d√©clencher le signal
    window.activeTrade = {
        entryPrice: window.tripleBottomResult.entryPrice,
        tp: window.tripleBottomResult.entryPrice * 1.05,  // exemple TP 5%
        sl: window.tripleBottomResult.entryPrice * 0.975, // exemple SL 2.5%
        trailing: window.tripleBottomResult.entryPrice * 1.03,
        highest: window.tripleBottomResult.entryPrice,
        pattern: "triple"
    };

    console.log("üí∞ ACTIVE TRADE cr√©√© :", window.activeTrade);

    // D√©clencher l'affichage du signal imm√©diatement
    if (typeof window.simulateTrading === "function") {
        window.simulateTrading();
    }
});


//Simuler un Stop Loss
document.getElementById("simulate-stoploss").addEventListener("click", () => {
    if (!window.activeTrade) {
        console.warn("‚ö†Ô∏è Aucun trade actif ‚Üí impossible de simuler un stop loss.");
        return;
    }

    // Forcer un prix sous le stop loss
    window.price = window.activeTrade.sl * 0.95;
    console.log("üîª Simulation Stop Loss : prix forc√© √†", window.price);

    // On "r√©-injecte" ce prix dans le code TP/SL d√©j√† existant
    // en appelant le m√™me bloc que pour la d√©tection normale
    (function() {
        const closes = window.closes || [];
        const lastPrice = window.price || closes[closes.length - 1];
        if (!window.activeTrade) return;

        const { entryPrice, sl } = window.activeTrade;

        if (lastPrice <= sl) {
            console.log("üî• STOP LOSS d√©clench√© !", { lastPrice, sl, entryPrice });
            // Tout ton code actuel de log + fetch pour vendre
            // tu peux copier-coller exactement ce qui est dans ton bloc TP/SL
        }
    })();
});


  </script>
  </body>
</html>

